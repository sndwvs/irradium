From 955ef939467a628eb8da08e0d5eaefc9a3484cba Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Cartegnie?= <fcvlcdev@free.fr>
Date: Tue, 23 Apr 2024 13:13:30 +0700
Subject: [PATCH 1/6] codec: avcodec: map AYUV as RAWVIDEO with ffmpeg 6.0

---
 modules/codec/avcodec/fourcc.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/modules/codec/avcodec/fourcc.c b/modules/codec/avcodec/fourcc.c
index 9b9f04a40de1..9d1ea245a0d5 100644
--- a/modules/codec/avcodec/fourcc.c
+++ b/modules/codec/avcodec/fourcc.c
@@ -206,7 +206,11 @@ static const struct vlc_avcodec_fourcc video_codecs[] =
     /* AV_CODEC_ID_V210X */
     { VLC_CODEC_TMV, AV_CODEC_ID_TMV },
     { VLC_CODEC_V210, AV_CODEC_ID_V210 },
+#if LIBAVCODEC_VERSION_CHECK( 59, 42, 102 )
+    { VLC_CODEC_VUYA, AV_CODEC_ID_RAWVIDEO },
+#else
     { VLC_CODEC_VUYA, AV_CODEC_ID_AYUV },
+#endif
     /* AV_CODEC_ID_DPX */
     { VLC_CODEC_MAD, AV_CODEC_ID_MAD },
     { VLC_CODEC_FRWU, AV_CODEC_ID_FRWU },
-- 
GitLab


From cbbcb4eb1c4b7fe0686e1f497acff8dfa3bc1e01 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Cartegnie?= <fcvlcdev@free.fr>
Date: Thu, 2 May 2024 13:51:32 +0700
Subject: [PATCH 2/6] codec: avcodec: store using extended buf

---
 modules/codec/avcodec/video.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/modules/codec/avcodec/video.c b/modules/codec/avcodec/video.c
index c69b016c51f1..60d82f790315 100644
--- a/modules/codec/avcodec/video.c
+++ b/modules/codec/avcodec/video.c
@@ -1724,7 +1724,18 @@ static int lavc_va_GetFrame(struct AVCodecContext *ctx, AVFrame *frame)
     if (frame->buf[0] == NULL)
         frame->buf[0] = buf;
     else
-        frame->opaque_ref = buf;
+    {
+        AVBufferRef **extended_buf = av_realloc_array(frame->extended_buf,
+                                                      sizeof(*extended_buf),
+                                                      frame->nb_extended_buf + 1);
+        if(!extended_buf)
+        {
+            av_buffer_unref(&buf);
+            return -1;
+        }
+        frame->extended_buf = extended_buf;
+        frame->extended_buf[frame->nb_extended_buf++] = buf;
+    }
 
     frame->opaque = pic;
     return 0;
-- 
GitLab


From a55ec32ab3760d9edb6f05481cd3a981aa42878d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Cartegnie?= <fcvlcdev@free.fr>
Date: Tue, 23 Apr 2024 13:14:53 +0700
Subject: [PATCH 3/6] demux/mux: avformat: use ch_layout from ffmpeg 5.1

---
 modules/codec/avcodec/audio.c  | 2 +-
 modules/demux/avformat/demux.c | 4 ++++
 modules/demux/avformat/mux.c   | 4 ++++
 3 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/modules/codec/avcodec/audio.c b/modules/codec/avcodec/audio.c
index d0c8bae750b2..114b497b6b88 100644
--- a/modules/codec/avcodec/audio.c
+++ b/modules/codec/avcodec/audio.c
@@ -138,7 +138,7 @@ static int OpenAudioCodec( decoder_t *p_dec )
     }
 
     ctx->sample_rate = p_dec->fmt_in->audio.i_rate;
-#if LIBAVCODEC_VERSION_CHECK(59, 24, 100)
+#if LIBAVUTIL_VERSION_CHECK(56, 31, 100)
     av_channel_layout_default( &ctx->ch_layout, p_dec->fmt_in->audio.i_channels );
 #else
     ctx->channels = p_dec->fmt_in->audio.i_channels;
diff --git a/modules/demux/avformat/demux.c b/modules/demux/avformat/demux.c
index 743e0534901c..a8e9de5cba39 100644
--- a/modules/demux/avformat/demux.c
+++ b/modules/demux/avformat/demux.c
@@ -470,7 +470,11 @@ int avformat_OpenDemux( vlc_object_t *p_this )
             es_format_Init( &es_fmt, AUDIO_ES, fcc );
             es_fmt.i_original_fourcc = CodecTagToFourcc( cp->codec_tag );
             es_fmt.i_bitrate = cp->bit_rate;
+#if LIBAVUTIL_VERSION_CHECK(56, 31, 100)
+            es_fmt.audio.i_channels = cp->ch_layout.nb_channels;
+#else
             es_fmt.audio.i_channels = cp->channels;
+#endif
             es_fmt.audio.i_rate = cp->sample_rate;
             es_fmt.audio.i_bitspersample = cp->bits_per_coded_sample;
             es_fmt.audio.i_blockalign = cp->block_align;
diff --git a/modules/demux/avformat/mux.c b/modules/demux/avformat/mux.c
index 55fc891437c7..4edcec53f27e 100644
--- a/modules/demux/avformat/mux.c
+++ b/modules/demux/avformat/mux.c
@@ -271,7 +271,11 @@ static int AddStream( sout_mux_t *p_mux, sout_input_t *p_input )
     {
     case AUDIO_ES:
         codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
+#if LIBAVUTIL_VERSION_CHECK(56, 31, 100)
+        av_channel_layout_default( &codecpar->ch_layout, fmt->audio.i_channels );
+#else
         codecpar->channels = fmt->audio.i_channels;
+#endif
         codecpar->sample_rate = fmt->audio.i_rate;
         stream->time_base = (AVRational){1, codecpar->sample_rate};
         if (fmt->i_bitrate == 0) {
-- 
GitLab


From 43009915537344a81bb72b8d804d64329b545c05 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Cartegnie?= <fcvlcdev@free.fr>
Date: Tue, 23 Apr 2024 14:50:39 +0700
Subject: [PATCH 4/6] codec: avcodec: non directly use reordered opaque

---
 modules/codec/avcodec/video.c | 54 ++++++++++++++++++++++++++++-------
 1 file changed, 44 insertions(+), 10 deletions(-)

diff --git a/modules/codec/avcodec/video.c b/modules/codec/avcodec/video.c
index 60d82f790315..ce4b8b268e3f 100644
--- a/modules/codec/avcodec/video.c
+++ b/modules/codec/avcodec/video.c
@@ -150,6 +150,34 @@ static uint32_t ffmpeg_CodecTag( vlc_fourcc_t fcc )
 /*****************************************************************************
  * Local Functions
  *****************************************************************************/
+static void FrameInfoInit( decoder_sys_t *p_sys )
+{
+    AVCodecContext *p_context = p_sys->p_context;
+    p_context->reordered_opaque = 0;
+}
+
+static struct frame_info_s * FrameInfoGet( decoder_sys_t *p_sys, AVFrame *frame )
+{
+    return &p_sys->frame_info[frame->reordered_opaque % FRAME_INFO_DEPTH];
+}
+
+static struct frame_info_s * FrameInfoAdd( decoder_sys_t *p_sys, AVPacket *pkt )
+{
+    AVCodecContext *p_context = p_sys->p_context;
+    return &p_sys->frame_info[p_context->reordered_opaque++ % FRAME_INFO_DEPTH];
+}
+
+static int64_t NextPktSequenceNumber( decoder_sys_t *p_sys )
+{
+    AVCodecContext *p_context = p_sys->p_context;
+    return p_context->reordered_opaque;
+}
+
+static int64_t FrameSequenceNumber( const AVFrame *frame, const struct frame_info_s *info )
+{
+    VLC_UNUSED(info);
+    return frame->reordered_opaque;
+}
 
 static void lavc_Frame8PaletteCopy( video_palette_t *dst, const uint8_t *src )
 {
@@ -534,7 +562,8 @@ static int InitVideoDecCommon( decoder_t *p_dec )
      * PTS correctly */
     p_context->get_buffer2 = lavc_GetFrame;
     p_context->opaque = p_dec;
-    p_context->reordered_opaque = 0;
+
+    FrameInfoInit( p_sys );
 
     int max_thread_count;
     int i_thread_count = p_sys->b_hardware_only ? 1 : var_InheritInteger( p_dec, "avcodec-threads" );
@@ -875,7 +904,7 @@ static block_t * filter_earlydropped_blocks( decoder_t *p_dec, block_t *block )
         return block;
 
     if( p_sys->i_last_output_frame >= 0 &&
-        p_sys->p_context->reordered_opaque - p_sys->i_last_output_frame > 24 )
+        NextPktSequenceNumber( p_sys ) - p_sys->i_last_output_frame > 24 )
     {
         p_sys->framedrop = FRAMEDROP_AGGRESSIVE_RECOVER;
     }
@@ -887,7 +916,7 @@ static block_t * filter_earlydropped_blocks( decoder_t *p_dec, block_t *block )
         {
             msg_Err( p_dec, "more than %"PRId64" frames of late video -> "
                             "dropping frame (computer too slow ?)",
-                     p_sys->p_context->reordered_opaque - p_sys->i_last_output_frame );
+                     NextPktSequenceNumber( p_sys ) - p_sys->i_last_output_frame );
 
             vlc_mutex_lock(&p_sys->lock);
             date_Set( &p_sys->pts, VLC_TICK_INVALID ); /* To make sure we recover properly */
@@ -1334,6 +1363,16 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
                 p_block->i_dts = VLC_TICK_INVALID;
             }
 
+            struct frame_info_s *p_frame_info = FrameInfoAdd(p_sys, pkt);
+            if( !p_frame_info )
+            {
+                av_packet_free( &pkt );
+                b_error = true;
+                break;
+            }
+            p_frame_info->b_eos = p_block && (p_block->i_flags & BLOCK_FLAG_END_OF_SEQUENCE);
+            p_frame_info->b_display = b_need_output_picture;
+
             int ret = avcodec_send_packet(p_context, pkt);
             if( ret != 0 && ret != AVERROR(EAGAIN) )
             {
@@ -1346,11 +1385,6 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
                 break;
             }
 
-            struct frame_info_s *p_frame_info = &p_sys->frame_info[p_context->reordered_opaque % FRAME_INFO_DEPTH];
-            p_frame_info->b_eos = p_block && (p_block->i_flags & BLOCK_FLAG_END_OF_SEQUENCE);
-            p_frame_info->b_display = b_need_output_picture;
-
-            p_context->reordered_opaque++;
             i_used = ret != AVERROR(EAGAIN) ? pkt->size : 0;
             av_packet_free( &pkt );
 
@@ -1397,7 +1431,7 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
             continue;
         }
 
-        struct frame_info_s *p_frame_info = &p_sys->frame_info[frame->reordered_opaque % FRAME_INFO_DEPTH];
+        struct frame_info_s *p_frame_info = FrameInfoGet( p_sys, frame );
         if( p_frame_info->b_eos )
             p_sys->b_first_frame = true;
 
@@ -1427,7 +1461,7 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
         if( b_first_output_sequence )
         {
             update_late_frame_count( p_dec, p_block, vlc_tick_now(), i_pts,
-                                     i_next_pts, frame->reordered_opaque);
+                                    i_next_pts, FrameSequenceNumber( frame, p_frame_info ) );
             b_first_output_sequence = false;
         }
 
-- 
GitLab


From d29d0e3b4da2e400eddd1d611a5c767ac6ca7994 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Cartegnie?= <fcvlcdev@free.fr>
Date: Mon, 29 Apr 2024 12:23:38 +0700
Subject: [PATCH 5/6] avcodec: vaapi: wipe sidedata on frame cloning

does not apply to next frame

would be better to have a clone API for buffers only
---
 modules/codec/avcodec/vaapi.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/modules/codec/avcodec/vaapi.c b/modules/codec/avcodec/vaapi.c
index bb93c7cd705c..3f7b28c9e933 100644
--- a/modules/codec/avcodec/vaapi.c
+++ b/modules/codec/avcodec/vaapi.c
@@ -129,6 +129,9 @@ static int Get(vlc_va_t *va, picture_t *pic, AVCodecContext *ctx, AVFrame *frame
     vaapi_pic_ctx->ctx.surface = (uintptr_t) frame->data[3];
     vaapi_pic_ctx->ctx.va_dpy = vaapi_vctx->va_dpy;
     vaapi_pic_ctx->avframe = av_frame_clone(frame);
+#if LIBAVCODEC_VERSION_CHECK(61, 03, 100)
+    av_frame_side_data_free(&vaapi_pic_ctx->avframe->side_data, &vaapi_pic_ctx->avframe->nb_side_data);
+#endif
     vaapi_pic_ctx->cloned = false;
     vlc_vaapi_PicSetContext(pic, &vaapi_pic_ctx->ctx);
 
-- 
GitLab


From 6b413351fbdcb6e7bbb25dc693d4318b0b894c30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fran=C3=A7ois=20Cartegnie?= <fcvlcdev@free.fr>
Date: Fri, 26 Apr 2024 12:01:02 +0700
Subject: [PATCH 6/6] codec: avcodec: replace reordered_opaque with opaque_ref
 for ffmpeg 7.0

---
 modules/codec/avcodec/vaapi.c |  2 +
 modules/codec/avcodec/video.c | 95 +++++++++++++++++++++++++++++------
 2 files changed, 83 insertions(+), 14 deletions(-)

diff --git a/modules/codec/avcodec/vaapi.c b/modules/codec/avcodec/vaapi.c
index 3f7b28c9e933..6d3f2bb97a92 100644
--- a/modules/codec/avcodec/vaapi.c
+++ b/modules/codec/avcodec/vaapi.c
@@ -132,6 +132,8 @@ static int Get(vlc_va_t *va, picture_t *pic, AVCodecContext *ctx, AVFrame *frame
 #if LIBAVCODEC_VERSION_CHECK(61, 03, 100)
     av_frame_side_data_free(&vaapi_pic_ctx->avframe->side_data, &vaapi_pic_ctx->avframe->nb_side_data);
 #endif
+    av_buffer_unref(&vaapi_pic_ctx->avframe->opaque_ref);
+    vaapi_pic_ctx->avframe->opaque = NULL;
     vaapi_pic_ctx->cloned = false;
     vlc_vaapi_PicSetContext(pic, &vaapi_pic_ctx->ctx);
 
diff --git a/modules/codec/avcodec/video.c b/modules/codec/avcodec/video.c
index ce4b8b268e3f..d1df8a581c2c 100644
--- a/modules/codec/avcodec/video.c
+++ b/modules/codec/avcodec/video.c
@@ -62,10 +62,14 @@
 #include "../../packetizer/av1_obu.h"
 #include "../../packetizer/av1.h"
 #include "../cc.h"
-#define FRAME_INFO_DEPTH 64
+
+#define OPAQUE_REF_ONLY LIBAVCODEC_VERSION_CHECK( 59, 63, 100 )
 
 struct frame_info_s
 {
+#if OPAQUE_REF_ONLY
+    uint64_t i_sequence_number;
+#endif
     bool b_eos;
     bool b_display;
 };
@@ -91,7 +95,12 @@ typedef struct
     bool b_hardware_only;
     enum AVDiscard i_skip_frame;
 
+#if OPAQUE_REF_ONLY
+    uint64_t i_next_sequence_number;
+#else
+# define FRAME_INFO_DEPTH 64
     struct frame_info_s frame_info[FRAME_INFO_DEPTH];
+#endif
 
     enum
     {
@@ -150,33 +159,83 @@ static uint32_t ffmpeg_CodecTag( vlc_fourcc_t fcc )
 /*****************************************************************************
  * Local Functions
  *****************************************************************************/
+
 static void FrameInfoInit( decoder_sys_t *p_sys )
 {
+#if OPAQUE_REF_ONLY
+    p_sys->i_next_sequence_number = 0;
+#else
     AVCodecContext *p_context = p_sys->p_context;
     p_context->reordered_opaque = 0;
+#endif
 }
 
 static struct frame_info_s * FrameInfoGet( decoder_sys_t *p_sys, AVFrame *frame )
 {
+#if OPAQUE_REF_ONLY
+    /* There's no pkt to frame opaque mapping guarantee */
+    return (struct frame_info_s *) frame->opaque_ref->data;
+#else
     return &p_sys->frame_info[frame->reordered_opaque % FRAME_INFO_DEPTH];
+#endif
 }
 
 static struct frame_info_s * FrameInfoAdd( decoder_sys_t *p_sys, AVPacket *pkt )
 {
+#if OPAQUE_REF_ONLY
+    AVBufferRef *bufref = av_buffer_allocz(sizeof(struct frame_info_s));
+    if( !bufref )
+        return NULL;
+    pkt->opaque_ref = bufref;
+
+    struct frame_info_s *p_frame_info = (struct frame_info_s *) bufref->data;
+    p_frame_info->i_sequence_number = p_sys->i_next_sequence_number++;
+    return p_frame_info;
+#else
+    VLC_UNUSED(pkt);
     AVCodecContext *p_context = p_sys->p_context;
     return &p_sys->frame_info[p_context->reordered_opaque++ % FRAME_INFO_DEPTH];
+#endif
+}
+
+static bool FrameCanStoreInfo( const AVFrame *frame )
+{
+#if OPAQUE_REF_ONLY
+    return !!frame->opaque_ref;
+#else
+    return true;
+#endif
+}
+
+static void FrameSetPicture( AVFrame *frame, picture_t *pic )
+{
+    frame->opaque = pic;
+}
+
+static picture_t * FrameGetPicture( AVFrame *frame )
+{
+    return frame->opaque;
 }
 
 static int64_t NextPktSequenceNumber( decoder_sys_t *p_sys )
 {
+#if OPAQUE_REF_ONLY
+    return p_sys->i_next_sequence_number;
+#else
     AVCodecContext *p_context = p_sys->p_context;
     return p_context->reordered_opaque;
+#endif
 }
 
 static int64_t FrameSequenceNumber( const AVFrame *frame, const struct frame_info_s *info )
 {
+#if OPAQUE_REF_ONLY
+    VLC_UNUSED(frame);
+    return info->i_sequence_number;
+#else
     VLC_UNUSED(info);
     return frame->reordered_opaque;
+#endif
 }
 
 static void lavc_Frame8PaletteCopy( video_palette_t *dst, const uint8_t *src )
@@ -509,6 +568,10 @@ static int InitVideoDecCommon( decoder_t *p_dec )
     /* ***** Output always the frames ***** */
     p_context->flags |= AV_CODEC_FLAG_OUTPUT_CORRUPT;
 
+#if OPAQUE_REF_ONLY
+    p_context->flags |= AV_CODEC_FLAG_COPY_OPAQUE;
+#endif
+
 #if LIBAVCODEC_VERSION_CHECK( 61, 03, 100 )
     if( p_dec->fmt_in->i_codec == VLC_CODEC_VVC )
         p_context->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
@@ -1363,14 +1426,15 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
                 p_block->i_dts = VLC_TICK_INVALID;
             }
 
-            struct frame_info_s *p_frame_info = FrameInfoAdd(p_sys, pkt);
+            struct frame_info_s *p_frame_info = FrameInfoAdd( p_sys, pkt );
             if( !p_frame_info )
             {
                 av_packet_free( &pkt );
                 b_error = true;
                 break;
             }
-            p_frame_info->b_eos = p_block && (p_block->i_flags & BLOCK_FLAG_END_OF_SEQUENCE);
+            const bool b_eos = p_block && (p_block->i_flags & BLOCK_FLAG_END_OF_SEQUENCE);
+            p_frame_info->b_eos = b_eos;
             p_frame_info->b_display = b_need_output_picture;
 
             int ret = avcodec_send_packet(p_context, pkt);
@@ -1388,7 +1452,7 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
             i_used = ret != AVERROR(EAGAIN) ? pkt->size : 0;
             av_packet_free( &pkt );
 
-            if( p_frame_info->b_eos && !b_drained )
+            if( b_eos && !b_drained )
             {
                  avcodec_send_packet( p_context, NULL );
                  b_drained = true;
@@ -1432,7 +1496,7 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
         }
 
         struct frame_info_s *p_frame_info = FrameInfoGet( p_sys, frame );
-        if( p_frame_info->b_eos )
+        if( p_frame_info && p_frame_info->b_eos )
             p_sys->b_first_frame = true;
 
         vlc_mutex_lock(&p_sys->lock);
@@ -1460,12 +1524,13 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
 
         if( b_first_output_sequence )
         {
-            update_late_frame_count( p_dec, p_block, vlc_tick_now(), i_pts,
-                                    i_next_pts, FrameSequenceNumber( frame, p_frame_info ) );
+            if( p_frame_info )
+                update_late_frame_count( p_dec, p_block, vlc_tick_now(), i_pts,
+                                        i_next_pts, FrameSequenceNumber( frame, p_frame_info ) );
             b_first_output_sequence = false;
         }
 
-        if( !p_frame_info->b_display ||
+        if( (p_frame_info && !p_frame_info->b_display) ||
            ( !p_sys->p_va && !frame->linesize[0] ) ||
            ( p_dec->b_frame_drop_allowed && (frame->flags & AV_FRAME_FLAG_CORRUPT) &&
              !p_sys->b_show_corrupted ) )
@@ -1506,7 +1571,7 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
             }
         }
 
-        picture_t *p_pic = frame->opaque;
+        picture_t *p_pic = FrameGetPicture( frame );
         if( p_pic == NULL )
         {   /* When direct rendering is not used, get_format() and get_buffer()
              * might not be called. The output video format must be set here
@@ -1570,6 +1635,7 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
         p_pic->i_nb_fields = 2 + frame->repeat_pict;
         p_pic->b_progressive = !frame->interlaced_frame;
         p_pic->b_top_field_first = frame->top_field_first;
+        p_pic->b_still = p_frame_info && p_frame_info->b_eos;
 
         if (DecodeSidedata(p_dec, frame, p_pic))
             i_pts = VLC_TICK_INVALID;
@@ -1579,8 +1645,6 @@ static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
         /* Send decoded frame to vout */
         if (i_pts != VLC_TICK_INVALID)
         {
-            if(p_frame_info->b_eos)
-                p_pic->b_still = true;
             p_sys->b_first_frame = false;
             vlc_mutex_unlock(&p_sys->lock);
             decoder_QueueVideo( p_dec, p_pic );
@@ -1734,6 +1798,9 @@ static int lavc_va_GetFrame(struct AVCodecContext *ctx, AVFrame *frame)
     decoder_sys_t *p_sys = dec->p_sys;
     vlc_va_t *va = p_sys->p_va;
 
+    if(!FrameCanStoreInfo(frame))
+        return -1;
+
     picture_t *pic;
     pic = decoder_NewPicture(dec);
     if (pic == NULL)
@@ -1771,7 +1838,7 @@ static int lavc_va_GetFrame(struct AVCodecContext *ctx, AVFrame *frame)
         frame->extended_buf[frame->nb_extended_buf++] = buf;
     }
 
-    frame->opaque = pic;
+    FrameSetPicture( frame, pic );
     return 0;
 }
 
@@ -1839,7 +1906,7 @@ static int lavc_dr_GetFrame(struct AVCodecContext *ctx, AVFrame *frame)
         picture_Hold(pic);
     }
 
-    frame->opaque = pic;
+    FrameSetPicture( frame, pic );
     /* The loop above held one reference to the picture for each plane. */
     assert(pic->i_planes > 0);
     picture_Release(pic);
@@ -1866,7 +1933,7 @@ static int lavc_GetFrame(struct AVCodecContext *ctx, AVFrame *frame, int flags)
         frame->linesize[i] = 0;
         frame->buf[i] = NULL;
     }
-    frame->opaque = NULL;
+    FrameSetPicture( frame, NULL );
 
     vlc_mutex_lock(&sys->lock);
     if (sys->p_va == NULL)
-- 
GitLab

